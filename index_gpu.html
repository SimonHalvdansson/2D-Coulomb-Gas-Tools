<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sim (WebGPU)</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --accent: #4f8cff;
      --muted: #9aa4b2;
      --text: #e9eef5;
      --stat: #cdd6e3;
      --btn: #262c36;
      --btn-hover: #303846;
      --border: #212735;
      --canvas-border: #212735;
      --gap: 16px;
      --container-w: 98vw;
      --container-mt: 24px;
      --container-mb: 24px;
    }
    body.light {
      --bg: #f4f6fb;
      --panel: #ffffff;
      --accent: #2b6bff;
      --muted: #556070;
      --text: #0e1320;
      --stat: #162033;
      --btn: #e8ecf4;
      --btn-hover: #dde3ee;
      --border: #d8dee9;
      --canvas-border: #cfd7e5;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; }
    body{
      margin:0; padding:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:16px; color:var(--text); background:var(--bg);
    }
    #container{
      width: var(--container-w);
      margin: var(--container-mt) auto var(--container-mb) auto;
      display: grid;
      grid-template-columns: auto 1fr; /* canvas auto-sized, controls take remaining */
      gap: var(--gap);
      align-items: start;
      justify-content: center; /* keep centered */
    }
    #main-canvas{
      border:1px solid var(--canvas-border);
      background:#fff;
      border-radius:12px;
      display:block;
      width: 900px;  /* JS resizes to square */
      height: 900px;
    }
    #controls{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:16px;
      position: sticky;
      top: 16px;
      max-width: 520px;
    }
    .section{ margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed var(--border); }
    .section:last-child{ border-bottom:none; margin-bottom:0; }
    .header{ font-weight:700; color: var(--muted); letter-spacing:.02em; margin-bottom:8px; }
    .row{ display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .stat{ font-variant-numeric: tabular-nums; color: var(--stat); }
    button{
      padding:8px 10px; background:var(--btn); color:var(--text);
      border:1px solid var(--border); border-radius:8px; cursor:pointer;
      font: inherit;
      transition: background-color 150ms ease, color 150ms ease, border-color 150ms ease;
    }
    button:hover{ background: var(--btn-hover); }
    .pill{
      padding: 6px 10px; border-radius: 999px; background: #1b2130; border:1px solid var(--border); color: var(--muted);
    }
    body.light .pill{ background:#f0f4fb; }
    input[type="range"]{ width:100%; min-width:260px; accent-color: var(--accent); }
    #theme-toggle{ accent-color: var(--accent); } /* make checkbox blue */
    .kv{ display:grid; grid-template-columns: 160px 1fr; align-items:center; gap:8px 12px; }
    .kv-small{ display:grid; grid-template-columns: 120px 1fr; align-items:center; gap:8px 12px; }
    .controls-grid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    details{ border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    summary{ list-style:none; cursor:pointer; padding:10px 12px; background:#1a2030; color:#cfd7e5; }
    body.light summary{ background:#eef2f8; color:#162033; }
    summary::-webkit-details-marker{ display:none; }
    details .inner{ padding:12px; background:#121723; }
    body.light details .inner{ background:#fbfdff; }
    .legend{ color: var(--muted); font-size: 13px; }
    .spaced{ letter-spacing: .01em; }
    .buttons-wrap{ display:flex; flex-wrap:wrap; gap:6px; } /* particle buttons auto-wrap */
  </style>
</head>
<body>
<div id="container"> 
  <canvas id="main-canvas" width="900" height="900"></canvas>

  <div id="controls">
    <div class="section">
      <div class="row" style="justify-content: space-between;">
        <div class="header spaced">Simulation</div>
        <label class="row pill" style="gap:6px;">
          <input type="checkbox" id="theme-toggle" checked>
          <span>Dark mode</span>
        </label>
      </div>
      <div class="controls-grid">
        <div class="kv">
          <div>Steps per frame</div>
          <input type="range" min="1" max="100" value="1" id="rangejumps">
        </div>
        <div class="kv">
          <div>Δt</div>
          <!-- dt = value / 30000 (range dialed back) -->
          <input type="range" min="1" max="40" value="5" id="rangedt">
        </div>
        <div class="row" style="justify-content: space-between;">
          <div>Frames: <span id="counter" class="stat">0</span></div>
          <div>Average speed: <span id="speed" class="stat">…</span></div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="header">Potential</div>
      <div class="row" style="gap:6px;">
        <button onclick="setPot(0)">Ginibre</button>
        <button onclick="setPot(1)">Mittag-Leffler λ=2</button>
        <button onclick="setPot(2)">Mittag-Leffler λ=10</button>
        <button onclick="setPot(3)">Lemniscate k=2</button>
        <button onclick="setPot(4)">Lemniscate k=3</button>
        <button onclick="setPot(5)">Lemniscate k=5</button>
        <button onclick="setPot(6)">Lemniscate (interpolated)</button>
      </div>
    </div>

    <div class="section">
      <div class="header">Number of particles</div>
      <div class="buttons-wrap">
        <button onclick="setN(2)">2</button>
        <button onclick="setN(50)">50</button>
        <button onclick="setN(100)">100</button>
        <button onclick="setN(200)">200</button>
        <button onclick="setN(500)">500</button>
        <button onclick="setN(1000)">1&thinsp;000</button>
        <button onclick="setN(2000)">2&thinsp;000</button>
        <button onclick="setN(5000)">5&thinsp;000</button>
        <button onclick="setN(10000)">10&thinsp;000</button>
        <button onclick="setN(20000)">20&thinsp;000</button>
        <button onclick="setN(50000)">50&thinsp;000</button>
        <button onclick="setN(100000)">100&thinsp;000</button>
        <button onclick="setN(200000)">200&thinsp;000</button>
        <button onclick="setN(500000)">500&thinsp;000</button>
      </div>
      <div class="legend" style="margin-top:6px;">
        Exact pairwise repulsion is O(n²); very large n may be slow.
      </div>
    </div>

    <div class="section">
      <div class="header">Rendering</div>
      <div class="row" style="gap:12px; flex-wrap:wrap;">
        <div class="kv-small" style="flex:1 1 260px;">
          <div>Particle radius</div>
          <input type="range" min="1" max="10" value="3" id="rangesize">
        </div>
        <div class="kv-small" style="flex:1 1 260px;">
          <div>Particle opacity</div>
          <input type="range" min="0.1" max="1.0" step="0.05" value="1.0" id="rangeopacity">
        </div>
      </div>
    </div>

    <div class="section">
      <details>
        <summary>Advanced ▸ Lemniscate & inserted scaling</summary>
        <div class="inner">
          <div class="kv">
            <div>Critical scaling</div>
            <input type="range" min="0" max="100" value="50" id="rangelem">
          </div>
          <div class="kv">
            <div>Interpolation (Lemniscate)</div>
            <input type="range" min="10" max="50" value="25" id="rangeleminterpol">
          </div>

          <div class="header" style="margin-top:10px;">Inserted scaled settings</div>
          <div class="kv">
            <div>ca</div><input type="range" min="0" max="100" value="0" id="rangeca">
          </div>
          <div class="kv">
            <div>ax</div><input type="range" min="-50" max="50" value="0" id="rangeax">
          </div>
          <div class="kv">
            <div>ay</div><input type="range" min="-50" max="50" value="0" id="rangeay">
          </div>
          <div class="kv">
            <div>cb</div><input type="range" min="0" max="100" value="0" id="rangecb">
          </div>
          <div class="kv">
            <div>bx</div><input type="range" min="-50" max="50" value="0" id="rangebx">
          </div>
          <div class="kv">
            <div>by</div><input type="range" min="-50" max="50" value="0" id="rangeby">
          </div>
        </div>
      </details>
    </div>
  </div>
</div>

<script>
/* ===== UI refs ===== */
const canvas = document.getElementById('main-canvas');
const controlsPanel = document.getElementById('controls');
const themeToggle = document.getElementById('theme-toggle');
const ctxCounter = document.getElementById('counter');
const ctxSpeed   = document.getElementById('speed');

const rangejumps = document.getElementById('rangejumps');
const rangedt    = document.getElementById('rangedt');
const rangelem   = document.getElementById('rangelem');
const rangeleminterpol = document.getElementById('rangeleminterpol');
const rangeca = document.getElementById('rangeca');
const rangeax = document.getElementById('rangeax');
const rangeay = document.getElementById('rangeay');
const rangecb = document.getElementById('rangecb');
const rangebx = document.getElementById('rangebx');
const rangeby = document.getElementById('rangeby');
const rangesize = document.getElementById('rangesize');
const rangeopacity = document.getElementById('rangeopacity');

/* ===== Sim state ===== */
let n = 20000;                 // default 20k
let steps = parseInt(rangejumps.value, 10);
let dt = parseFloat(rangedt.value) / 30000.0;
let particleSizePx = parseInt(rangesize.value, 10);
let userOpacity = parseFloat(rangeopacity.value);
let frameCounter = 0;

let pot = 0;
let lemniscateT = parseFloat(rangelem.value)/50.0;
let lemInterpol = parseFloat(rangeleminterpol.value)/10.0;
let ca = 0, cb = 0, ax = 0, ay = 0, bx = 0, by = 0;

const h = 1e-4;
const damping = 0.8;
let isDark = true;
const simToClip = 0.7;

/* ===== WebGPU ===== */
let device, queue, context, canvasFormat;
let computePipeline, renderPipeline;
let simParamsBuf, renderParamsBuf, renderBindGroup;
let posA, posB, velA, velB;
let quadVB;
let stagingVel;

let ping = 0;
const WG_SIZE = 256;

let speedReadbackEvery = 20;
let lastSpeedReadback = -999999;
let speedMappingInFlight = false;

/* ---- Responsive square canvas ---- */
function resizeCanvasSquare() {
  const gap = 16;
  const sideMargins = (window.innerWidth * 0.02);
  const topBottom = 24 + 24;

  const maxH = Math.max(300, window.innerHeight - topBottom);
  const controlsW = controlsPanel.getBoundingClientRect().width;
  const maxW = Math.max(300, window.innerWidth - controlsW - gap - sideMargins);

  const size = Math.max(300, Math.min(maxH, maxW));

  canvas.style.width = size + 'px';
  canvas.style.height = size + 'px';
  if (canvas.width !== size || canvas.height !== size) {
    canvas.width = size;
    canvas.height = size;
    writeRenderParams();
  }
}
window.addEventListener('resize', resizeCanvasSquare);

/* ===== WebGPU setup ===== */
async function initWebGPU() {
  if (!('gpu' in navigator)) {
    alert('WebGPU is not supported in this browser.');
    throw new Error('No WebGPU');
  }
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) throw new Error('No GPU adapter');
  device = await adapter.requestDevice();
  queue = device.queue;

  context = canvas.getContext('webgpu');
  canvasFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format: canvasFormat, alphaMode: 'opaque' });

  createRenderParamsBuf();
  createSimParamsBuf();
  createQuadVB();

  await createPipelines();
  await createParticleBuffers(n, true);

  resizeCanvasSquare();
  requestAnimationFrame(frame);
}

function createQuadVB() {
  const quad = new Float32Array([
    -0.5, -0.5,
     0.5, -0.5,
     0.5,  0.5,
    -0.5, -0.5,
     0.5,  0.5,
    -0.5,  0.5,
  ]);
  quadVB = device.createBuffer({
    size: quad.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true
  });
  new Float32Array(quadVB.getMappedRange()).set(quad);
  quadVB.unmap();
}

function createSimParamsBuf() {
  simParamsBuf = device.createBuffer({
    size: 64,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  writeSimParams();
}

function createRenderParamsBuf() {
  // simToClip, particleSizePx, canvasW, canvasH, alpha, isDark, pad, pad
  renderParamsBuf = device.createBuffer({
    size: 32,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  writeRenderParams();
}

function writeSimParams() {
  // 4 u32s: n, pot, pad0, pad1
  const u32 = new Uint32Array(4);
  u32[0] = n >>> 0;
  u32[1] = pot >>> 0;
  u32[2] = 0;
  u32[3] = 0;

  const f32 = new Float32Array([
    dt, h, damping, lemniscateT,
    lemInterpol, ca, cb, ax,
    ay, bx, by, 0.0
  ]);

  const buf = new ArrayBuffer(u32.byteLength + f32.byteLength);
  new Uint32Array(buf, 0, 4).set(u32);
  new Float32Array(buf, u32.byteLength, f32.length).set(f32);
  queue.writeBuffer(simParamsBuf, 0, buf);
}

function writeRenderParams() {
  const f32 = new Float32Array([
    simToClip, particleSizePx, canvas.width, canvas.height,
    userOpacity, isDark ? 1.0 : 0.0, 0, 0
  ]);
  queue.writeBuffer(renderParamsBuf, 0, f32);
}

async function createPipelines() {
  const computeWGSL = `
const WG_SIZE : u32 = 256u;

struct SimParams {
  n: u32,
  pot: u32,
  _pad0: u32,
  _pad1: u32,
  dt: f32,
  h: f32,
  damping: f32,
  lemniscateT: f32,
  lemInterpol: f32,
  ca: f32,
  cb: f32,
  ax: f32,
  ay: f32,
  bx: f32,
  by: f32,
};

@group(0) @binding(0) var<storage, read>  posIn : array<vec2<f32>>;
@group(0) @binding(1) var<storage, read>  velIn : array<vec2<f32>>;
@group(0) @binding(2) var<storage, read_write> posOut: array<vec2<f32>>;
@group(0) @binding(3) var<storage, read_write> velOut: array<vec2<f32>>;
@group(0) @binding(4) var<uniform> params : SimParams;

fn Q(x: f32, y: f32) -> f32 {
  let r = sqrt(x*x + y*y);
  let theta = atan2(y, x);

  var q: f32 = 0.0;
  switch(params.pot) {
    case 0u: { q = x*x + y*y; }
    case 1u: { q = pow(x*x + y*y, 2.0); }
    case 2u: { q = pow(x*x + y*y, 10.0); }
    case 3u: { q = pow(x*x + y*y, 2.0) - params.lemniscateT * 2.0 / sqrt(2.0) * pow(r, 2.0) * cos(2.0*theta); }
    case 4u: { q = pow(x*x + y*y, 3.0) - params.lemniscateT * 2.0 / sqrt(3.0) * pow(r, 3.0) * cos(3.0*theta); }
    case 5u: { q = pow(x*x + y*y, 3.0) - params.lemniscateT * 2.0 / sqrt(5.0) * pow(r, 5.0) * cos(5.0*theta); }
    case 6u: { q = pow(x*x + y*y, params.lemInterpol)
                   - params.lemniscateT * 2.0 / sqrt(params.lemInterpol)
                     * pow(r, params.lemInterpol) * cos(params.lemInterpol*theta); }
    default: {}
  }

  let dx1 = x - params.ax;
  let dy1 = y + params.ay;
  let dx2 = x - params.bx;
  let dy2 = y - params.by;
  let eps = 1e-6;
  let d1sq = dx1*dx1 + dy1*dy1 + eps;
  let d2sq = dx2*dx2 + dy2*dy2 + eps;
  q = q + (-params.cb * 0.5 * log(d2sq) - params.ca * 0.5 * log(d1sq));
  return q;
}

var<workgroup> tilePos: array<vec2<f32>, WG_SIZE>;

@compute @workgroup_size(WG_SIZE)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {

  let i = gid.x;
  let N = params.n;

  var px: f32 = 0.0;
  var py: f32 = 0.0;
  var vx: f32 = 0.0;
  var vy: f32 = 0.0;

  if (i < N) {
    px = posIn[i].x;
    py = posIn[i].y;
    vx = velIn[i].x;
    vy = velIn[i].y;
  }

  let q0 = Q(px, py);
  var accx = -f32(N) * (Q(px + params.h, py) - q0) / params.h;
  var accy = -f32(N) * (Q(px, py + params.h) - q0) / params.h;

  var tileStart: u32 = 0u;
  loop {
    if (tileStart >= N) { break; }

    let j = tileStart + lid.x;
    if (j < N) {
      tilePos[lid.x] = posIn[j];
    } else {
      tilePos[lid.x] = vec2<f32>(1e9, 1e9);
    }
    workgroupBarrier();

    let count = min(WG_SIZE, N - tileStart);
    var k: u32 = 0u;
    loop {
      if (k >= count) { break; }
      let jg = tileStart + k;

      if (jg != i) {
        let dx = tilePos[k].x - px;
        let dy = tilePos[k].y - py;
        let den = dx*dx + dy*dy + 1e-6;
        accx -= (2.0 * dx) / den;
        accy -= (2.0 * dy) / den;
      }

      k = k + 1u; // exact pairs
    }
    workgroupBarrier();

    tileStart = tileStart + WG_SIZE;
  }

  if (i < N) {
    vx = vx + accx * params.dt;
    vy = vy + accy * params.dt;

    px = px + vx * params.dt;
    py = py + vy * params.dt;

    vx = vx * params.damping;
    vy = vy * params.damping;

    posOut[i] = vec2<f32>(px, py);
    velOut[i] = vec2<f32>(vx, vy);
  }
}
  `;

  const renderWGSL = `
struct RenderParams {
  simToClip: f32,       // a0
  particleSizePx: f32,  // a1
  canvasW: f32,         // a2
  canvasH: f32,         // a3
  alpha: f32,           // b0
  isDark: f32,          // b1 (1=dark)
  _padB: f32,           // b2
  _padC: f32,           // b3
};

@group(0) @binding(0) var<uniform> rp: RenderParams;

struct VSOut { @builtin(position) pos: vec4<f32>, };

@vertex
fn vs_main(@location(0) quadPos: vec2<f32>,
           @location(1) instPos: vec2<f32>) -> VSOut {
  var out: VSOut;
  var base = vec2<f32>(instPos.x * rp.simToClip,
                       instPos.y * rp.simToClip);
  let offClip = vec2<f32>(
    quadPos.x * rp.particleSizePx * 2.0 / rp.canvasW,
    -quadPos.y * rp.particleSizePx * 2.0 / rp.canvasH
  );
  out.pos = vec4<f32>(base + offClip, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // Dark mode: light particles; Light mode: dark particles
  let particle = select(vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(1.0, 1.0, 1.0), rp.isDark > 0.5);
  return vec4<f32>(particle, rp.alpha);
}
  `;

  const csModule = device.createShaderModule({code: computeWGSL});
  const vsfsModule = device.createShaderModule({code: renderWGSL});

  computePipeline = device.createComputePipeline({
    layout: 'auto',
    compute: { module: csModule, entryPoint: 'main' }
  });

  renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: vsfsModule,
      entryPoint: 'vs_main',
      buffers: [
        { arrayStride: 2*4, stepMode: 'vertex', attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] },
        { arrayStride: 2*4, stepMode: 'instance', attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }] }
      ]
    },
    fragment: {
      module: vsfsModule,
      entryPoint: 'fs_main',
      targets: [{
        format: canvasFormat,
        blend: {
          color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
          alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
        }
      }]
    },
    primitive: { topology: 'triangle-list' }
  });

  renderBindGroup = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: renderParamsBuf } }],
  });
}

async function createParticleBuffers(N, randomize=false) {
  const bytes = N * 2 * 4;

  posA = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  posB = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  velA = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  velB = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });

  if (randomize) {
    const pos = new Float32Array(N*2);
    const vel = new Float32Array(N*2);
    for (let i=0;i<N;i++){
      pos[2*i+0] = (Math.random()-0.5)*2.7;
      pos[2*i+1] = (Math.random()-0.5)*2.7;
      vel[2*i+0] = 0;
      vel[2*i+1] = 0;
    }
    queue.writeBuffer(posA, 0, pos);
    queue.writeBuffer(posB, 0, pos);
    queue.writeBuffer(velA, 0, vel);
    queue.writeBuffer(velB, 0, vel);
  }

  stagingVel = device.createBuffer({ size: bytes, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
}

function getBindGroup(pingNow){
  const readPos  = pingNow === 0 ? posA : posB;
  const readVel  = pingNow === 0 ? velA : velB;
  const writePos = pingNow === 0 ? posB : posA;
  const writeVel = pingNow === 0 ? velB : velA;

  return {
    bg: device.createBindGroup({
      layout: computePipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: readPos } },
        { binding: 1, resource: { buffer: readVel } },
        { binding: 2, resource: { buffer: writePos } },
        { binding: 3, resource: { buffer: writeVel } },
        { binding: 4, resource: { buffer: simParamsBuf } },
      ]
    })
  };
}

function getRenderBuffers() { return ping === 0 ? posB : posA; }

async function frame() {
  const encoder = device.createCommandEncoder();

  writeSimParams();
  for (let s=0; s<steps; s++){
    const { bg } = getBindGroup(ping);
    const pass = encoder.beginComputePass();
    pass.setPipeline(computePipeline);
    pass.setBindGroup(0, bg);
    pass.dispatchWorkgroups(Math.ceil(n / WG_SIZE));
    pass.end();
    ping ^= 1;
  }

  if (!speedMappingInFlight && (frameCounter - lastSpeedReadback) >= speedReadbackEvery) {
    const currentVel = ping === 0 ? velB : velA;
    encoder.copyBufferToBuffer(currentVel, 0, stagingVel, 0, n*2*4);
    lastSpeedReadback = frameCounter;
    speedMappingInFlight = true;
  }

  const currentPos = getRenderBuffers();
  const texView = context.getCurrentTexture().createView();
  const clearCol = isDark ? {r:0.05,g:0.06,b:0.08,a:1} : {r:1,g:1,b:1,a:1};
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{ view: texView, clearValue: clearCol, loadOp: 'clear', storeOp: 'store' }]
  });
  renderPass.setPipeline(renderPipeline);
  renderPass.setBindGroup(0, renderBindGroup);
  renderPass.setVertexBuffer(0, quadVB);
  renderPass.setVertexBuffer(1, currentPos);
  renderPass.draw(6, n, 0, 0);
  renderPass.end();

  device.queue.submit([encoder.finish()]);

  if (speedMappingInFlight && frameCounter === lastSpeedReadback) {
    stagingVel.mapAsync(GPUMapMode.READ).then(() => {
      const arr = new Float32Array(stagingVel.getMappedRange());
      let sum = 0.0;
      for (let i=0;i<n;i++){
        const vx = arr[2*i+0], vy = arr[2*i+1];
        sum += Math.hypot(vx, vy);
      }
      ctxSpeed.textContent = (sum / n).toFixed(6);
      stagingVel.unmap();
      speedMappingInFlight = false;
    }).catch(()=>{ speedMappingInFlight = false; });
  }

  frameCounter++;
  ctxCounter.textContent = frameCounter.toString();
  requestAnimationFrame(frame);
}

/* ===== UI handlers ===== */
function setPot(p){ pot = p; writeSimParams(); }
function setParticleSize(px){
  particleSizePx = px;
  rangesize.value = String(px);
  writeRenderParams();
}
function setOpacity(a){
  userOpacity = a;
  writeRenderParams();
}

function setN(N){
  n = N;

  // Auto-assign particle radius based on N
  if (n <= 500) setParticleSize(4);
  else if (n === 1000 || n === 2000) setParticleSize(3);
  else if (n === 5000) setParticleSize(2);
  else setParticleSize(1);

  // For 200k or 500k reset dt to default start value (5/30000)
  if (n === 200000 || n === 500000) {
    rangedt.value = 5;
    dt = 5 / 30000.0;
    writeSimParams();
  }

  // Optional: set an initial opacity suggestion based on n (but user slider rules)
  if (n >= 500000) rangeopacity.value = 0.3;
  else if (n >= 200000) rangeopacity.value = 0.4;
  else if (n >= 100000) rangeopacity.value = 0.5;
  else if (n >= 50000)  rangeopacity.value = 0.7;
  else rangeopacity.value = 1.0;
  setOpacity(parseFloat(rangeopacity.value));

  writeRenderParams();
  createParticleBuffers(n, true);
  ping = 0;
  frameCounter = 0;
  lastSpeedReadback = -999999;
  speedMappingInFlight = false;
  ctxSpeed.textContent = '…';

  resizeCanvasSquare();
}

rangejumps.oninput = () => { steps = parseInt(rangejumps.value, 10); };
rangedt.oninput    = () => { dt = parseFloat(rangedt.value)/30000.0; writeSimParams(); };

rangelem.oninput = () => { lemniscateT = parseFloat(rangelem.value)/50.0; writeSimParams(); };
rangeleminterpol.oninput = () => { lemInterpol = parseFloat(rangeleminterpol.value)/10.0; writeSimParams(); };

rangeca.oninput = () => { ca = parseFloat(rangeca.value)/100.0; writeSimParams(); };
rangeax.oninput = () => { ax = parseFloat(rangeax.value)/50.0; writeSimParams(); };
rangeay.oninput = () => { ay = parseFloat(rangeay.value)/50.0; writeSimParams(); };
rangecb.oninput = () => { cb = parseFloat(rangecb.value)/100.0; writeSimParams(); };
rangebx.oninput = () => { bx = parseFloat(rangebx.value)/50.0; writeSimParams(); };
rangeby.oninput = () => { by = parseFloat(rangeby.value)/50.0; writeSimParams(); };

rangesize.oninput = () => { setParticleSize(parseInt(rangesize.value, 10)); };
rangeopacity.oninput = () => { setOpacity(parseFloat(rangeopacity.value)); };

themeToggle.addEventListener('change', () => {
  isDark = themeToggle.checked;
  document.body.classList.toggle('light', !isDark);
  writeRenderParams();
});

/* Expose for buttons */
window.setPot = setPot;
window.setN = setN;
window.setParticleSize = setParticleSize;

/* ===== Kickoff ===== */
initWebGPU().then(resizeCanvasSquare).catch(err => {
  console.error(err);
  alert('Failed to initialize WebGPU. Try Chrome/Edge with chrome://flags/#enable-unsafe-webgpu enabled.');
});
</script>
</body>
</html>
