<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sim (WebGPU)</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --accent: #4f8cff;
      --muted: #9aa4b2;
      --text: #e9eef5;
      --stat: #cdd6e3;
      --btn: #262c36;
      --btn-hover: #303846;
      --border: #212735;
      --canvas-border: #212735;
      --gap: 16px;
    }
    body.light {
      --bg: #f4f6fb;
      --panel: #ffffff;
      --accent: #2b6bff;
      --muted: #556070;
      --text: #0e1320;
      --stat: #162033;
      --btn: #e8ecf4;
      --btn-hover: #dde3ee;
      --border: #d8dee9;
      --canvas-border: #cfd7e5;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; overflow:hidden; }
    body{
      margin:0; padding:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:16px; color:var(--text); background:var(--bg);
    }

    /* ---------- Layout ---------- */
    #container{
      height:100vh;
      display:grid;
      grid-template-columns: auto auto;
      grid-auto-rows: 1fr;
      gap: var(--gap);
      align-items: start;
      justify-content: center;
      padding: 12px;
    }
    #main-canvas{
      border:1px solid var(--canvas-border);
      background:#fff;
      border-radius:12px;
      display:block;
      width: 900px;
      height: 900px;
    }
    #controls{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:16px;
      position: relative;
      max-width: 520px;
      max-height: calc(100vh - 24px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Portrait: controls under canvas, scroll inside panel */
    body.portrait #container{
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
      justify-items: center;
    }
    body.portrait #controls{
      width: min(760px, 96vw);
      max-width: 96vw;
      overflow-y: auto;
    }

    /* Firefox */
#controls{
  scrollbar-width: thin;                 /* thin | auto */
  scrollbar-color: var(--btn-hover) transparent;
  scrollbar-gutter: stable;              /* avoids layout shift when bar appears */
}

/* WebKit (Chrome/Edge/Safari) */
#controls::-webkit-scrollbar{
  width: 10px;
}
#controls::-webkit-scrollbar-track{
  background: transparent;
}
#controls::-webkit-scrollbar-thumb{
  background-color: var(--btn);
  border-radius: 8px;
  border: 2px solid transparent;        /* creates inset look */
  background-clip: content-box;
}
#controls::-webkit-scrollbar-thumb:hover{
  background-color: var(--btn-hover);
}

/* Optional: native dark/light scrollbars where supported */
body:not(.light) #controls{ color-scheme: dark; }
body.light #controls{ color-scheme: light; }

    /* Compact controls when the panel gets narrow */
    #controls.compact { font-size:14px; }
    #controls.compact .kv { grid-template-columns: 140px 1fr; }
    #controls.compact button { padding:7px 9px; }

    /* ---------- UI atoms ---------- */
    .section{ margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed var(--border); }
    .section:last-child{ border-bottom:none; margin-bottom:0; }
    .header{ font-weight:700; color: var(--muted); letter-spacing:.02em; margin-bottom:8px; }
    .row{ display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .stat{ font-variant-numeric: tabular-nums; color: var(--stat); }
    button, .link-button{
      padding:8px 10px; background: var(--btn); color: var(--text);
      border:1px solid var(--border); border-radius:8px; cursor:pointer;
      font: inherit;
      transition: background-color 150ms ease, color 150ms ease, border-color 150ms ease, transform 150ms ease;
      text-decoration:none;
      display:inline-block;
    }
    button:hover, .link-button:hover{ background: var(--btn-hover); }
    .toggle-group button.active{
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .pill{
      padding: 6px 10px; border-radius: 999px; background: #1b2130; border:1px solid var(--border); color: var(--muted);
    }
    body.light .pill{ background:#f0f4fb; }
    input[type="range"]{ width:100%; min-width:260px; accent-color: var(--accent); }
    #theme-toggle{ accent-color: var(--accent); }
    .kv{ display:grid; grid-template-columns: 160px 1fr; align-items:center; gap:8px 12px; }
    .kv-small{ display:grid; grid-template-columns: 120px 1fr; align-items:center; gap:8px 12px; }
    .controls-grid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    details{ border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    summary{ list-style:none; cursor:pointer; padding:10px 12px; background:#1a2030; color:#cfd7e5; }
    body.light summary{ background:#eef2f8; color:#162033; }
    summary::-webkit-details-marker{ display:none; }
    details .inner{ padding:12px; background:#121723; }
    body.light details .inner{ background:#fbfdff; }
    .legend{ color: var(--muted); font-size: 13px; }
    .spaced{ letter-spacing: .01em; }
    .buttons-wrap{ display:flex; flex-wrap:wrap; gap:6px; }
  </style>
</head>
<body>
<div id="container">
  <canvas id="main-canvas" width="900" height="900"></canvas>

  <div id="controls">
    <div class="section">
      <div class="row" style="justify-content: space-between;">
        <div class="header spaced">Simulation</div>
        <label class="row pill" style="gap:6px;">
          <input type="checkbox" id="theme-toggle" checked>
          <span>Dark mode</span>
        </label>
      </div>
      <div class="controls-grid">
        <div class="kv">
          <div>Steps per frame</div>
          <input type="range" min="1" max="100" value="1" id="rangejumps">
        </div>
        <div class="kv">
          <div>Δt</div>
          <input type="range" min="1" max="40" value="5" id="rangedt">
        </div>
          <div class="row" style="justify-content: flex-start; gap:24px;">
            <div>Frames: <span id="counter" class="stat">0</span></div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="header">What is this?</div>
        <div class="row" style="flex-direction:column; align-items:flex-start; gap:8px;">
          <div>Each dot represents an electron which experiences pariwise Couolmb repulsions with all other electrons. The collection of particles does not disperse due to the confining potential which explodes at infinite. The minimum energy configuration is known as a <i>Fekete configuration</i>. For more on the background and context of these systems see my bachelor thesis below.</div>
          <a href="https://simonhalvdansson.github.io/bachelor_thesis.pdf" target="_blank" class="link-button">PDF</a>
        </div>
      </div>

      <div class="section">
        <div class="header">Potential</div>
        <div class="row toggle-group" id="pot-group" style="gap:6px;">
          <button data-pot="0">Ginibre</button>
        <button data-pot="1">Mittag-Leffler λ=2</button>
        <button data-pot="2">Mittag-Leffler λ=10</button>
        <button data-pot="3">Lemniscate k=2</button>
        <button data-pot="4">Lemniscate k=3</button>
        <button data-pot="5">Lemniscate k=5</button>
        <button data-pot="6">Lemniscate (interpolated)</button>
      </div>
    </div>

    <div class="section">
      <div class="header">Number of particles</div>
      <div class="buttons-wrap toggle-group" id="n-group">
        <button data-n="2">2</button>
        <button data-n="50">50</button>
        <button data-n="100">100</button>
        <button data-n="200">200</button>
        <button data-n="500">500</button>
        <button data-n="1000">1&thinsp;000</button>
        <button data-n="2000">2&thinsp;000</button>
        <button data-n="5000">5&thinsp;000</button>
        <button data-n="10000">10&thinsp;000</button>
        <button data-n="20000">20&thinsp;000</button>
        <button data-n="50000">50&thinsp;000</button>
        <button data-n="100000">100&thinsp;000</button>
        <button data-n="200000">200&thinsp;000</button>
        <button data-n="500000">500&thinsp;000</button>
      </div>
      <div class="legend" style="margin-top:6px;">
        Exact pairwise repulsion is O(n²); very large n may be slow.
      </div>
    </div>

    <div class="section">
      <div class="header">Rendering</div>
      <div class="row" style="gap:12px; flex-wrap:wrap;">
        <div class="kv-small" style="flex:1 1 260px;">
          <div>Particle radius</div>
          <input type="range" min="1" max="10" value="1" id="rangesize">
        </div>
        <div class="kv-small" style="flex:1 1 260px;">
          <div>Particle opacity</div>
          <input type="range" min="0.1" max="1.0" step="0.05" value="1.0" id="rangeopacity">
        </div>
      </div>
    </div>

    <div class="section">
      <details>
        <summary>Advanced ▸ Lemniscate & inserted scaling</summary>
        <div class="inner">
          <div class="kv">
            <div>Critical scaling</div>
            <input type="range" min="0" max="100" value="50" id="rangelem">
          </div>
          <div class="kv">
            <div>Interpolation (Lemniscate)</div>
            <input type="range" min="10" max="50" value="25" id="rangeleminterpol">
          </div>

          <div class="header" style="margin-top:10px;">Inserted scaled settings</div>
          <div class="kv">
            <div>ca</div><input type="range" min="0" max="100" value="0" id="rangeca">
          </div>
          <div class="kv">
            <div>ax</div><input type="range" min="-50" max="50" value="0" id="rangeax">
          </div>
          <div class="kv">
            <div>ay</div><input type="range" min="-50" max="50" value="0" id="rangeay">
          </div>
          <div class="kv">
            <div>cb</div><input type="range" min="0" max="100" value="0" id="rangecb">
          </div>
          <div class="kv">
            <div>bx</div><input type="range" min="-50" max="50" value="0" id="rangebx">
          </div>
          <div class="kv">
            <div>by</div><input type="range" min="-50" max="50" value="0" id="rangeby">
          </div>
        </div>
      </details>
    </div>
  </div>
</div>

<script>
/* ===== UI refs ===== */
const canvas = document.getElementById('main-canvas');
const controlsPanel = document.getElementById('controls');
const potGroup = document.getElementById('pot-group');
const nGroup = document.getElementById('n-group');
const themeToggle = document.getElementById('theme-toggle');

const rangejumps = document.getElementById('rangejumps');
const rangedt    = document.getElementById('rangedt');
const rangelem   = document.getElementById('rangelem');
const rangeleminterpol = document.getElementById('rangeleminterpol');
const rangeca = document.getElementById('rangeca');
const rangeax = document.getElementById('rangeax');
const rangeay = document.getElementById('rangeay');
const rangecb = document.getElementById('rangecb');
const rangebx = document.getElementById('rangebx');
const rangeby = document.getElementById('rangeby');
const rangesize = document.getElementById('rangesize');
const rangeopacity = document.getElementById('rangeopacity');

const counterEl = document.getElementById('counter');

/* ===== Sim state ===== */
let n = 20000;                       // default 20k
let steps = parseInt(rangejumps.value, 10);
let dt = parseFloat(rangedt.value) / 30000.0;
let particleSizePx = defaultRadiusForN(n);
let userOpacity = parseFloat(rangeopacity.value);
let frameCounter = 0;

let pot = 0;
let lemniscateT = parseFloat(rangelem.value)/50.0;
let lemInterpol = parseFloat(rangeleminterpol.value)/10.0;
let ca = 0, cb = 0, ax = 0, ay = 0, bx = 0, by = 0;

const h = 1e-4; // still used only if needed elsewhere
const damping = 0.8;
let isDark = true;
const simToClip = 0.7;

/* ===== WebGPU ===== */
let adapter, device, queue, context, canvasFormat;
let computePipeline, renderPipeline;
let simParamsBuf, renderParamsBuf, renderBindGroup;
let posA, posB, velA, velB;
let quadVB;
let ping = 0;

// Dynamic WG size (choose 128 or 256)
let WG_SIZE_JS = 256;
let computeBG = [];       // [A->B, B->A]
let numGroups = 0;

// dirty flags: avoid uniform writes unless changed
let simDirty = true;
let renderDirty = true;

/* ---- Responsive & layout ---- */
function isPortrait() { return window.innerHeight > window.innerWidth; }

function resizeCanvasSquare() {
  const gap = 16;
  const pad = 24;
  let size;

  if (isPortrait()) {
    document.body.classList.add('portrait');
    const maxW = Math.max(300, window.innerWidth - pad*2);
    const maxH = Math.max(300, window.innerHeight - pad*2 - 200);
    size = Math.max(300, Math.min(maxW, maxH));
  } else {
    document.body.classList.remove('portrait');
    const controlsW = controlsPanel.getBoundingClientRect().width || 420;
    const maxW = Math.max(300, window.innerWidth - controlsW - gap - pad*2);
    const maxH = Math.max(300, window.innerHeight - pad*2);
    size = Math.max(300, Math.min(maxW, maxH));
  }

  canvas.style.width = size + 'px';
  canvas.style.height = size + 'px';
  if (canvas.width !== size || canvas.height !== size) {
    canvas.width = size;
    canvas.height = size;
    markRenderDirty();
  }
}

function adjustLayout() {
  const isCompact = (!isPortrait()) && (controlsPanel.getBoundingClientRect().width < 380);
  controlsPanel.classList.toggle('compact', isCompact);

  if (isPortrait()) {
    const rect = canvas.getBoundingClientRect();
    const remaining = window.innerHeight - rect.height - 16 - 24;
    controlsPanel.style.maxHeight = Math.max(180, remaining) + 'px';
    controlsPanel.style.overflowY = 'auto';
  } else {
  controlsPanel.style.maxHeight = 'leave'; // or leave '' to use the CSS rule
  controlsPanel.style.overflowY = 'auto';
  }
}

window.addEventListener('resize', () => { resizeCanvasSquare(); adjustLayout(); });

/* ===== WebGPU setup ===== */
async function initWebGPU() {
  if (!('gpu' in navigator)) {
    alert('WebGPU is not supported in this browser.');
    throw new Error('No WebGPU');
  }
  adapter = await navigator.gpu.requestAdapter();
  if (!adapter) throw new Error('No GPU adapter');

  // pick a good WG size
  try {
    const maxX = adapter.limits?.maxComputeWorkgroupSizeX ?? 256;
    WG_SIZE_JS = Math.min(256, Math.max(64, (maxX >= 256 ? 256 : (maxX >= 128 ? 128 : 64))));
  } catch { WG_SIZE_JS = 256; }

  device = await adapter.requestDevice();
  queue = device.queue;

  context = canvas.getContext('webgpu');
  canvasFormat = navigator.gpu.getPreferredCanvasFormat();
  context.configure({ device, format: canvasFormat, alphaMode: 'opaque' });

  createRenderParamsBuf();
  createSimParamsBuf();
  createQuadVB();

  await createPipelines();          // uses WG_SIZE_JS
  await createParticleBuffers(n, true);  // builds bind groups + numGroups

  // Sync initial UI state
  rangesize.value = String(particleSizePx);
  setActiveButtons();

  resizeCanvasSquare();
  adjustLayout();
  requestAnimationFrame(frame);
}

function createQuadVB() {
  const quad = new Float32Array([
    -0.5, -0.5,
     0.5, -0.5,
     0.5,  0.5,
    -0.5, -0.5,
     0.5,  0.5,
    -0.5,  0.5,
  ]);
  quadVB = device.createBuffer({
    size: quad.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    mappedAtCreation: true
  });
  new Float32Array(quadVB.getMappedRange()).set(quad);
  quadVB.unmap();
}

function createSimParamsBuf() {
  simParamsBuf = device.createBuffer({
    size: 64,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  simDirty = true;
}

function createRenderParamsBuf() {
  renderParamsBuf = device.createBuffer({
    size: 32,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  renderDirty = true;
}

function markSimDirty(){ simDirty = true; }
function markRenderDirty(){ renderDirty = true; }

function writeSimParams() {
  if (!simDirty) return;
  const u32 = new Uint32Array(4);
  u32[0] = n >>> 0;
  u32[1] = pot >>> 0;
  u32[2] = 0;
  u32[3] = 0;

  const f32 = new Float32Array([
    dt, h, damping, lemniscateT,
    lemInterpol, ca, cb, ax,
    ay, bx, by, 0.0
  ]);

  const buf = new ArrayBuffer(u32.byteLength + f32.byteLength);
  new Uint32Array(buf, 0, 4).set(u32);
  new Float32Array(buf, u32.byteLength, f32.length).set(f32);
  queue.writeBuffer(simParamsBuf, 0, buf);
  simDirty = false;
}

function writeRenderParams() {
  if (!renderDirty) return;
  const f32 = new Float32Array([
    simToClip, particleSizePx, canvas.width, canvas.height,
    userOpacity, isDark ? 1.0 : 0.0, 0, 0
  ]);
  queue.writeBuffer(renderParamsBuf, 0, f32);
  renderDirty = false;
}

async function createPipelines() {
  const computeWGSL = `
const WG_SIZE : u32 = ${WG_SIZE_JS}u;

struct SimParams {
  n: u32,
  pot: u32,
  _pad0: u32,
  _pad1: u32,
  dt: f32,
  h: f32,
  damping: f32,
  lemniscateT: f32,
  lemInterpol: f32,
  ca: f32,
  cb: f32,
  ax: f32,
  ay: f32,
  bx: f32,
  by: f32,
};

@group(0) @binding(0) var<storage, read>  posIn : array<vec2<f32>>;
@group(0) @binding(1) var<storage, read>  velIn : array<vec2<f32>>;
@group(0) @binding(2) var<storage, read_write> posOut: array<vec2<f32>>;
@group(0) @binding(3) var<storage, read_write> velOut: array<vec2<f32>>;
@group(0) @binding(4) var<uniform> params : SimParams;

/* -------- helper: analytic + hybrid confining gradient -------- */
fn grad_logs(x: f32, y: f32) -> vec2<f32> {
  let dx1 = x - params.ax;
  let dy1 = y + params.ay;
  let dx2 = x - params.bx;
  let dy2 = y - params.by;
  let eps = 1e-6;
  let d1 = dx1*dx1 + dy1*dy1 + eps;
  let d2 = dx2*dx2 + dy2*dy2 + eps;
  let gx = -params.ca * dx1 / d1 + -params.cb * dx2 / d2;
  let gy = -params.ca * dy1 / d1 + -params.cb * dy2 / d2;
  return vec2<f32>(gx, gy);
}

fn grad_f2_interp(x:f32, y:f32, p:f32) -> vec2<f32> {
  let r2 = x*x + y*y + 1e-12;
  let r  = sqrt(r2);
  let th = atan2(y, x);
  let c  = cos(p * th);
  let s  = sin(p * th);
  let sc = p * pow(r, p - 2.0);
  return vec2<f32>( sc*(x*c + y*s), sc*(y*c - x*s) );
}

fn grad_conf(x: f32, y: f32) -> vec2<f32> {
  let r2 = x*x + y*y;
  let r4 = r2*r2;
  var gx: f32 = 0.0;
  var gy: f32 = 0.0;

  switch(params.pot) {
    // Ginibre: (x^2 + y^2)
    case 0u: {
      gx = 2.0 * x;
      gy = 2.0 * y;
    }
    // Mittag-Leffler λ=2: (x^2 + y^2)^2
    case 1u: {
      gx = 4.0 * r2 * x;
      gy = 4.0 * r2 * y;
    }
    // Mittag-Leffler λ=10: (x^2 + y^2)^10
    case 2u: {
      let r8 = r4*r4;
      let s = 20.0 * r8 * r2; // 20 * r2^9
      gx = s * x;
      gy = s * y;
    }
    // Lemniscate k=2: r^4 - c*(x^2 - y^2), c = T*2/sqrt(2)
    case 3u: {
      let c = params.lemniscateT * 2.0 / sqrt(2.0);
      gx = 4.0 * r2 * x - 2.0 * c * x;
      gy = 4.0 * r2 * y + 2.0 * c * y;
    }
    // Lemniscate k=3: r^6 - c*(x^3 - 3xy^2), c = T*2/sqrt(3)
    case 4u: {
      let c = params.lemniscateT * 2.0 / sqrt(3.0);
      let x2 = x*x; let y2 = y*y;
      gx = 6.0 * r4 * x - 3.0 * c * (x2 - y2);
      gy = 6.0 * r4 * y + 6.0 * c * x * y;
    }
    // Lemniscate k=5
    case 5u: {
      let c = params.lemniscateT * 2.0 / sqrt(5.0);
      let x2 = x*x; let y2 = y*y;
      let x3 = x2*x; let y3 = y2*y;
      let x4 = x2*x2; let y4 = y2*y2;
      let dPx = 5.0*x4 - 30.0*x2*y2 + 5.0*y4;
      let dPy = -20.0*x3*y + 20.0*x*y3;
      gx = 6.0 * r4 * x - c * dPx;
      gy = 6.0 * r4 * y - c * dPy;
    }
    // Interpolated lemniscate: analytic
    default: {
      let p = params.lemInterpol;
      let s = 2.0 * p * pow(r2, p - 1.0); // grad of r^{2p}
      var gx1 = s * x;
      var gy1 = s * y;
      let alpha = params.lemniscateT * 2.0 / sqrt(max(p, 1e-6));
      let g2 = grad_f2_interp(x, y, p);
      gx = gx1 - alpha * g2.x;
      gy = gy1 - alpha * g2.y;
    }
  }

  let gl = grad_logs(x, y);
  return vec2<f32>(gx + gl.x, gy + gl.y);
}

var<workgroup> tilePos: array<vec2<f32>, WG_SIZE>;

@compute @workgroup_size(WG_SIZE)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {

  let i = gid.x;
  let N = params.n;

  var px: f32 = 0.0;
  var py: f32 = 0.0;
  var vx: f32 = 0.0;
  var vy: f32 = 0.0;

  if (i < N) {
    px = posIn[i].x;
    py = posIn[i].y;
    vx = velIn[i].x;
    vy = velIn[i].y;
  }

  // Confining potential gradient
  var g = grad_conf(px, py);
  var accx = -f32(N) * g.x;
  var accy = -f32(N) * g.y;

  // Tiled pairwise repulsion (exact)
  var tileStart: u32 = 0u;
  loop {
    if (tileStart >= N) { break; }

    let j = tileStart + lid.x;
    if (j < N) {
      tilePos[lid.x] = posIn[j];
    }
    workgroupBarrier();

    let count: u32 = min(WG_SIZE, N - tileStart);
    var k: u32 = 0u;
    loop {
      if (k >= count) { break; }
      let dx = tilePos[k].x - px;
      let dy = tilePos[k].y - py;
      let inv = 1.0 / (dx*dx + dy*dy + 1e-6);
      let scale = 2.0 * inv;
      // skip self-term without branch: it contributes zero when i==tileStart+k
      if (tileStart + k != i) {
        accx -= dx * scale;
        accy -= dy * scale;
      }
      k = k + 1u;
    }
    workgroupBarrier();

    tileStart = tileStart + WG_SIZE;
  }

  if (i < N) {
    vx = vx + accx * params.dt;
    vy = vy + accy * params.dt;

    px = px + vx * params.dt;
    py = py + vy * params.dt;

    vx = vx * params.damping;
    vy = vy * params.damping;

    posOut[i] = vec2<f32>(px, py);
    velOut[i] = vec2<f32>(vx, vy);
  }
}
  `;

  const renderWGSL = `
struct RenderParams {
  simToClip: f32,
  particleSizePx: f32,
  canvasW: f32,
  canvasH: f32,
  alpha: f32,
  isDark: f32,
  _padB: f32,
  _padC: f32,
};

@group(0) @binding(0) var<uniform> rp: RenderParams;

struct VSOut { @builtin(position) pos: vec4<f32>, };

@vertex
fn vs_main(@location(0) quadPos: vec2<f32>,
           @location(1) instPos: vec2<f32>) -> VSOut {
  var out: VSOut;
  var base = vec2<f32>(instPos.x * rp.simToClip,
                       instPos.y * rp.simToClip);
  let offClip = vec2<f32>(
    quadPos.x * rp.particleSizePx * 2.0 / rp.canvasW,
    -quadPos.y * rp.particleSizePx * 2.0 / rp.canvasH
  );
  out.pos = vec4<f32>(base + offClip, 0.0, 1.0);
  return out;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  let particle = select(vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(1.0, 1.0, 1.0), rp.isDark > 0.5);
  return vec4<f32>(particle, rp.alpha);
}
  `;

  const csModule = device.createShaderModule({code: computeWGSL});
  const vsfsModule = device.createShaderModule({code: renderWGSL});

  computePipeline = device.createComputePipeline({
    layout: 'auto',
    compute: { module: csModule, entryPoint: 'main' }
  });

  renderPipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: vsfsModule,
      entryPoint: 'vs_main',
      buffers: [
        { arrayStride: 2*4, stepMode: 'vertex', attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] },
        { arrayStride: 2*4, stepMode: 'instance', attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x2' }] }
      ]
    },
    fragment: {
      module: vsfsModule,
      entryPoint: 'fs_main',
      targets: [{
        format: canvasFormat,
        blend: {
          color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
          alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
        }
      }]
    },
    primitive: { topology: 'triangle-list' }
  });

  renderBindGroup = device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [{ binding: 0, resource: { buffer: renderParamsBuf } }],
  });
}

async function createParticleBuffers(N, randomize=false) {
  const bytes = N * 2 * 4;

  // No COPY_SRC flags; no init for B buffers
  posA = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
  posB = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX });
  velA = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
  velB = device.createBuffer({ size: bytes, usage: GPUBufferUsage.STORAGE });

  if (randomize) {
    const pos = new Float32Array(N*2);
    const vel = new Float32Array(N*2);
    for (let i=0;i<N;i++){
      pos[2*i+0] = (Math.random()-0.5)*2.7;
      pos[2*i+1] = (Math.random()-0.5)*2.7;
      vel[2*i+0] = 0;
      vel[2*i+1] = 0;
    }
    queue.writeBuffer(posA, 0, pos);
    queue.writeBuffer(velA, 0, vel);
  }

  const layout = computePipeline.getBindGroupLayout(0);
  computeBG = [
    device.createBindGroup({ layout, entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: posB } },
      { binding: 3, resource: { buffer: velB } },
      { binding: 4, resource: { buffer: simParamsBuf } },
    ]}),
    device.createBindGroup({ layout, entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: posA } },
      { binding: 3, resource: { buffer: velA } },
      { binding: 4, resource: { buffer: simParamsBuf } },
    ]}),
  ];
  numGroups = Math.ceil(n / WG_SIZE_JS);
}

/* After stepping, the last written buffer is (ping==1? B : A) */
function getRenderBuffer() { return (ping === 1) ? posB : posA; }

async function frame() {
  const encoder = device.createCommandEncoder();

  writeSimParams();
  writeRenderParams();

  // Single compute pass with reused bind groups
  const cpass = encoder.beginComputePass();
  cpass.setPipeline(computePipeline);
  for (let s=0; s<steps; s++){
    cpass.setBindGroup(0, computeBG[ping]);
    cpass.dispatchWorkgroups(numGroups);
    ping ^= 1;
  }
  cpass.end();

  // Render
  const currentPos = getRenderBuffer();
  const texView = context.getCurrentTexture().createView();
  const clearCol = isDark ? {r:0.05,g:0.06,b:0.08,a:1} : {r:1,g:1,b:1,a:1};
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{ view: texView, clearValue: clearCol, loadOp: 'clear', storeOp: 'store' }]
  });
  renderPass.setPipeline(renderPipeline);
  renderPass.setBindGroup(0, renderBindGroup);
  renderPass.setVertexBuffer(0, quadVB);
  renderPass.setVertexBuffer(1, currentPos);
  renderPass.draw(6, n, 0, 0);
  renderPass.end();

  device.queue.submit([encoder.finish()]);

  // Keep per-frame counter update
  frameCounter++;
  counterEl.textContent = frameCounter.toString();

  requestAnimationFrame(frame);
}

/* ===== Helpers & UI ===== */
function defaultRadiusForN(N){
  if (N <= 500) return 4;
  if (N === 1000 || N === 2000) return 3;
  if (N === 5000) return 2;
  return 1;
}

function setActiveButtons(){
  potGroup.querySelectorAll('button').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.pot) === pot);
  });
  nGroup.querySelectorAll('button').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.n) === n);
  });
}

potGroup.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-pot]');
  if (!btn) return;
  setPot(parseInt(btn.dataset.pot));
  setActiveButtons();
});

nGroup.addEventListener('click', (e) => {
  const btn = e.target.closest('button[data-n]');
  if (!btn) return;
  setN(parseInt(btn.dataset.n));
  setActiveButtons();
});

function setPot(p){ pot = p; markSimDirty(); }
function setParticleSize(px){
  particleSizePx = px;
  rangesize.value = String(px);
  markRenderDirty();
}
function setOpacity(a){
  userOpacity = a;
  markRenderDirty();
}

function setN(N){
  n = N;

  // Auto radius per your rules
  setParticleSize(defaultRadiusForN(n));

  // Reset dt for heavy cases
  if (n === 200000 || n === 500000) {
    rangedt.value = 5;
    dt = 5 / 30000.0;
    markSimDirty();
  }

  createParticleBuffers(n, true);
  ping = 0;
  frameCounter = 0;
  counterEl.textContent = '0';

  markRenderDirty();
  markSimDirty();

  resizeCanvasSquare();
  adjustLayout();
}

rangejumps.oninput = () => { steps = parseInt(rangejumps.value, 10); };
rangedt.oninput    = () => { dt = parseFloat(rangedt.value)/30000.0; markSimDirty(); };

rangelem.oninput = () => { lemniscateT = parseFloat(rangelem.value)/50.0; markSimDirty(); };
rangeleminterpol.oninput = () => { lemInterpol = parseFloat(rangeleminterpol.value)/10.0; markSimDirty(); };

rangeca.oninput = () => { ca = parseFloat(rangeca.value)/100.0; markSimDirty(); };
rangeax.oninput = () => { ax = parseFloat(rangeax.value)/50.0; markSimDirty(); };
rangeay.oninput = () => { ay = parseFloat(rangeay.value)/50.0; markSimDirty(); };
rangecb.oninput = () => { cb = parseFloat(rangecb.value)/100.0; markSimDirty(); };
rangebx.oninput = () => { bx = parseFloat(rangebx.value)/50.0; markSimDirty(); };
rangeby.oninput = () => { by = parseFloat(rangeby.value)/50.0; markSimDirty(); };

rangesize.oninput = () => { setParticleSize(parseInt(rangesize.value, 10)); };
rangeopacity.oninput = () => { setOpacity(parseFloat(rangeopacity.value)); };

themeToggle.addEventListener('change', () => {
  isDark = themeToggle.checked;
  document.body.classList.toggle('light', !isDark);
  markRenderDirty();
});

/* ===== Kickoff ===== */
initWebGPU().catch(err => {
  console.error(err);
  alert('Failed to initialize WebGPU. Try Chrome/Edge with chrome://flags/#enable-unsafe-webgpu enabled.');
});
</script>
</body>
</html>
